//@version=6
strategy('9:00PM first trade + immediate re-entry (SL/TP)',
     overlay = true,
     margin_long = 50,
     margin_short = 50,
     process_orders_on_close=false,
     calc_on_every_tick = true,
     initial_capital = 1500,
     default_qty_type = strategy.percent_of_equity,
     default_qty_value = 15,
     pyramiding = 1)

// === INPUTS ===
tp_percent = input.float(0.5, 'Take Profit (%)', step = 0.1)
sl_percent = input.float(0.01, 'Stop Loss (%)', step = 0.1)
start_hour = input.int(21, 'First trade hour (24h)')
start_minute = input.int(0, 'First trade minute')

// === STATE VARIABLES (declared up-front) ===
var int direction = 1 // 1 = long, -1 = short
var bool firstTradeDone = false
var float sl_price = na
var float tp_price = na
var float last_entry_price = na
var float exit_price = na
var float profitPerc = na
var float initial_equity = na

// current position size (series)
pos_size = strategy.position_size

if barstate.isfirst
    initial_equity := strategy.equity

// === 1) First trade at 21:00 (only once) ===
isStartBar = hour(time) == start_hour and minute(time) == start_minute
if isStartBar and not firstTradeDone and pos_size == 0
    if direction == 1
        strategy.entry('Long', strategy.long)
    else
        strategy.entry('Short', strategy.short)
    firstTradeDone := true

// === 2) Capture entry price once a position opens ===
if pos_size != 0 and na(last_entry_price)
    last_entry_price := strategy.position_avg_price

// === 3) Compute SL/TP absolute price levels and attach strategy.exit ===
if pos_size > 0
    sl_price := strategy.position_avg_price * (1 - sl_percent / 100)
    tp_price := strategy.position_avg_price * (1 + tp_percent / 100)
    strategy.exit('ExitLong', from_entry = 'Long', stop = sl_price, limit = tp_price)
else if pos_size < 0
    sl_price := strategy.position_avg_price * (1 + sl_percent / 100)
    tp_price := strategy.position_avg_price * (1 - tp_percent / 100)
    strategy.exit('ExitShort', from_entry = 'Short', stop = sl_price, limit = tp_price)

// === 4) Detect closed position and immediately re-enter ===
was_in_position_prev = strategy.position_size[1] != 0 // Use [1] for previous bar
now_flat = pos_size == 0

if was_in_position_prev and now_flat
    exit_price := close

    if strategy.position_size[1] > 0
        profitPerc := (exit_price - last_entry_price) / last_entry_price * 100
    else
        profitPerc := (last_entry_price - exit_price) / last_entry_price * 100

    if profitPerc < 0
        direction := -direction

    last_entry_price := na

    if direction == 1
        strategy.entry('Long', strategy.long)
    else
        strategy.entry('Short', strategy.short)

// === 5) Dynamic quantity (15% of equity) ===
// Get current equity in USD
position_value_usd = initial_equity * 0.15

// Estimate quantity (contracts or coin units)
qty = position_value_usd / close

// === 6) Webhook alert ===
// Only send alert if sl_price and tp_price have been calculated (i.e., we are in a trade)
var string symbol_to_send = ""

if not na(sl_price) and not na(tp_price)
    side_str = direction == 1 ? "buy" : "sell"
    
    // Extract the raw symbol (e.g., "BTCUSDT") from the full ticker ID (e.g., "BITUNIX:BTCUSDT")
    var string symbol_to_send = na
    if str.contains(syminfo.tickerid, ":")
        // Split the ticker ID by ":" and take the last part
        symbol_parts = str.split(syminfo.tickerid, ":")
        symbol_to_send := array.get(symbol_parts, array.size(symbol_parts) - 1)
    else
        // If no ":" is present, assume it's already the raw symbol
        symbol_to_send := syminfo.tickerid

    sl_str = str.tostring(sl_price, format.mintick)
    tp_str = str.tostring(tp_price, format.mintick)
    qty_str = str.tostring(qty, format.mintick)

    // Build the JSON alert message using the cleaned symbol name
    alert_msg = "{\"side\":\"" + side_str + "\",\"symbol\":\"" + symbol_to_send + "\",\"sl\":" + sl_str + ",\"tp\":" + tp_str + ",\"quantity\":" + qty_str + ",\"guaranteed_stop_loss\":true}"
    alert(alert_msg, alert.freq_once_per_bar)

// === Debug labels (optional) ===
var showDebug = input.bool(false, 'Show debug labels')
if showDebug
    label.new(bar_index, high, text = 'dir: ' + str.tostring(direction) + '\ninitial_equity: ' + str.tostring(initial_equity, format.mintick) + '\nSymbol: ' + symbol_to_send, yloc = yloc.abovebar, style = label.style_label_left, textcolor = color.white, size = size.small)

